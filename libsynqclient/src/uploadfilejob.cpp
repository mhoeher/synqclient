/*
 * Copyright 2020 Martin Hoeher <martin@rpdev.net>
 *
 * This file is part of SynqClient.
 *
 * SynqClient is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * SynqClient is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SynqClient.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "../inc/uploadfilejob.h"

#include <QBuffer>
#include <QFile>
#include <QIODevice>

#include "uploadfilejobprivate.h"

namespace SynqClient {

UploadFileJob::UploadFileJob(QObject* parent) : AbstractJob(new UploadFileJobPrivate(this), parent)
{
}

UploadFileJob::~UploadFileJob() {}

QString UploadFileJob::localFilename() const
{
    Q_D(const UploadFileJob);
    return d->localFilename;
}

void UploadFileJob::setLocalFilename(const QString& localFilename)
{
    Q_D(UploadFileJob);
    d->localFilename = localFilename;
    d->input.reset();
    d->data.clear();
    d->sourceType = UploadFileJobPrivate::UploadSource::Path;
}

QIODevice* UploadFileJob::input() const
{
    Q_D(const UploadFileJob);
    return d->input.data();
}

/**
 * @brief Set the input device to read data from.
 *
 * This sets the @p input device from which the data to be uplaoded is taken from.
 * Note that this must be a sequential device with a known size.
 *
 * The job takes ownership of the device. It will be destroyed once the job is destroyed.
 */
void UploadFileJob::setInput(QIODevice* input)
{
    Q_D(UploadFileJob);
    d->localFilename.clear();
    d->input.reset(input);
    d->data.clear();
    if (input) {
        d->sourceType = UploadFileJobPrivate::UploadSource::IODevice;
    } else {
        d->sourceType = UploadFileJobPrivate::UploadSource::Invalid;
    }
}

QByteArray UploadFileJob::data() const
{
    Q_D(const UploadFileJob);
    return d->data;
}

void UploadFileJob::setData(const QByteArray& data)
{
    Q_D(UploadFileJob);
    d->localFilename.clear();
    d->input.reset();
    d->data = data;
    d->sourceType = UploadFileJobPrivate::UploadSource::Data;
}

QString UploadFileJob::remoteFilename() const
{
    Q_D(const UploadFileJob);
    return d->remoteFilename;
}

void UploadFileJob::setRemoteFilename(const QString& remoteFilename)
{
    Q_D(UploadFileJob);
    d->remoteFilename = remoteFilename;
}

/**
 * @brief Meta information about the file just uploaded.
 *
 * This returns meta information about the file which has just been
 * uploaded. Depending on the concrete implementation, this might include some
 * immediate information like the ItemProperty::SyncAttribute which was
 * generated by uploading the file.
 */
QVariantMap UploadFileJob::fileInfo() const
{
    Q_D(const UploadFileJob);
    return d->fileInfo;
}

/**
 * @brief Upload only if the remote and this sync attribute matches.
 *
 * If this property is set to a valid (i.e. non-null) sync-attribute, the
 * upload should only succeed if the remote current sync attribute matches
 * the one set here. This can be used to prevent lost updates.
 *
 * @note The implementation of this is specific to the concrete protocols used.
 * If a protocol does not provide measures to handle conditional
 * uploads, it might be ignored completely.
 */
QVariant UploadFileJob::syncAttribute() const
{
    Q_D(const UploadFileJob);
    return d->syncAttribute;
}

/**
 * @brief Set the expected @p syncAttribute of the remote file.
 */
void UploadFileJob::setSyncAttribute(const QVariant& syncAttribute)
{
    Q_D(UploadFileJob);
    d->syncAttribute = syncAttribute;
}

UploadFileJob::UploadFileJob(UploadFileJobPrivate* d, QObject* parent) : AbstractJob(d, parent) {}

/**
 * @brief Get the device to use for uploading data.
 *
 * This returns a shared pointer to a QIODevice used for uploading data. The device is constructed
 * from the set input source. If the input is invalid (e.g. not set, points to a non-existing
 * file, etc), a nullpts is returned and an appropriate error is set.
 */
QSharedPointer<QIODevice> UploadFileJob::getUploadDevice()
{
    Q_D(UploadFileJob);
    switch (d->sourceType) {
    case UploadFileJobPrivate::UploadSource::Invalid:
        setError(JobError::MissingParameter, "No input set for upload");
        return nullptr;
    case UploadFileJobPrivate::UploadSource::Data: {
        auto result = QSharedPointer<QIODevice>(new QBuffer(&d->data));
        result->open(QIODevice::ReadOnly);
        return result;
    }
    case UploadFileJobPrivate::UploadSource::IODevice:
        if (d->input.isNull()) {
            setError(JobError::InvalidParameter, "Input device set to nullptr");
        }
        return d->input;
    case UploadFileJobPrivate::UploadSource::Path:
        QFile* file = new QFile(d->localFilename);
        if (file->open(QIODevice::ReadOnly)) {
            return QSharedPointer<QIODevice>(file);
        } else {
            setError(JobError::InvalidParameter,
                     QString("Failed to open %1 for reading: %2")
                             .arg(d->localFilename)
                             .arg(file->errorString()));
            delete file;
            return nullptr;
        }
        break;
    }
    setError(JobError::InvalidParameter, "Unexpected configuration for upload");
    return nullptr;
}

/**
 * @brief Set file meta information.
 *
 * This method shall be used by classes implementing this job to set the file
 * meta information for the file which has been uploaded.
 */
void UploadFileJob::setFileInfo(const QVariantMap& fileInfo)
{
    Q_D(UploadFileJob);
    d->fileInfo = fileInfo;
}

} // namespace SynqClient
